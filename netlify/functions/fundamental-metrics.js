exports.handler = async function(event, context) {
  console.log('üöÄ Netlify Function: fundamental-metrics started');
  
  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'
      },
      body: ''
    };
  }

  // Only allow POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ error: 'Method not allowed. Use POST.' })
    };
  }

  try {
    // Parse request body
    const { coinSymbol, coinName } = JSON.parse(event.body || '{}');
    
    if (!coinSymbol || !coinName) {
      throw new Error('Missing required parameters: coinSymbol and coinName');
    }

    console.log(`üìä Fetching fundamental metrics for ${coinName} (${coinSymbol})`);

    // Secure API key access from environment
    const apiKey = process.env.PPLX_API_KEY;
    
    if (!apiKey) {
      throw new Error('PPLX_API_KEY environment variable not set');
    }

    // Enhanced research prompt for fundamental metrics
    const prompt = `Provide comprehensive fundamental analysis data for ${coinName} (${coinSymbol}) cryptocurrency. 

Research and provide specific numerical data for these metrics (respond with "N/A" if data unavailable):

## Token Economics & Supply
1. Token unlock schedule: What percentage of tokens unlock in the next 12 months?
2. Total Value Locked (TVL): Current TVL in USD
3. Supply dynamics: Is the token inflationary, deflationary, or stable? Current inflation/deflation rate?
4. Current circulating supply vs max supply
5. Token distribution: Percentage held by top 10 wallets

## Network Activity & Adoption  
6. Active addresses: Daily/monthly active addresses
7. Transaction volume: Daily transaction count and volume in USD
8. Protocol revenue: Monthly revenue generated by the protocol in USD
9. Fully Diluted Valuation (FDV): Current FDV in USD
10. Number of users: Active protocol users

## Technical & Development
11. Development activity: GitHub commits in last 30 days
12. Security audits: Number of completed security audits
13. On-chain activity: Transaction count growth trend
14. Liquidity: Total liquidity available across exchanges

## Market & Community
15. Trading volume: 24-hour trading volume in USD
16. Community size: Combined Twitter + Discord followers
17. Partnerships: Number of major partnerships or integrations
18. Ecosystem flows: Cross-chain transaction volume if applicable

## Financial Ratios
19. P/F ratio: Price-to-Fees ratio if applicable
20. MCap/TVL ratio: Market Cap to TVL ratio

Please format your response as JSON with this exact structure:
{
  "tokenUnlockSchedule": {"value": number, "unit": "percentage"},
  "tvl": {"value": number, "unit": "USD"},
  "supplyDynamics": {"type": "inflationary/deflationary/stable", "rate": number},
  "activeAddresses": {"value": number, "period": "daily/monthly"},
  "transactionVolume": {"count": number, "valueUSD": number},
  "protocolRevenue": {"value": number, "unit": "USD", "period": "monthly"},
  "fdv": {"value": number, "unit": "USD"},
  "users": {"value": number},
  "developmentActivity": {"commits": number, "period": "30 days"},
  "securityAudits": {"count": number},
  "onChainActivity": {"trend": "increasing/decreasing/stable"},
  "liquidity": {"value": number, "unit": "USD"},
  "tradingVolume": {"value": number, "unit": "USD", "period": "24h"},
  "communitySize": {"followers": number},
  "partnerships": {"count": number},
  "ecosystemFlows": {"value": number, "unit": "USD"},
  "pfRatio": {"value": number},
  "mcapTvlRatio": {"value": number}
}

Provide only factual, verifiable data. Use "N/A" for any metrics that cannot be reliably determined.`;

    // Call Perplexity API with secure key
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout for comprehensive data
    
    const requestHeaders = {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    };

    const requestBody = {
      "model": "sonar-pro",
      "messages": [
        {
          "role": "user",
          "content": prompt
        }
      ]
    };

    console.log("üîÅ Sending to Perplexity:", requestBody);
    console.log("üìã Headers:", requestHeaders);
    console.log("üß† Prompt:", prompt);
    console.log("‚úÖ Model:", requestBody.model);
    
    const response = await fetch('https://api.perplexity.ai/chat/completions', {
      method: 'POST',
      headers: requestHeaders,
      body: JSON.stringify(requestBody),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`Perplexity API error! status: ${response.status}, statusText: ${response.statusText}`);
    }

    const data = await response.json();
    console.log('‚úÖ Perplexity fundamental metrics completed successfully');
    
    const metricsText = data.choices?.[0]?.message?.content;
    
    if (!metricsText) {
      throw new Error('No metrics content received from Perplexity API');
    }

    // Parse JSON from response
    let parsedMetrics;
    try {
      // Extract JSON from the response text
      const jsonMatch = metricsText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parsedMetrics = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {
      console.warn('Failed to parse JSON, using fallback structure');
      parsedMetrics = generateFallbackMetrics(coinSymbol);
    }

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        success: true,
        metrics: parsedMetrics,
        coin: {
          symbol: coinSymbol,
          name: coinName
        },
        timestamp: new Date().toISOString()
      })
    };
    
  } catch (error) {
    console.error('‚ùå Fundamental Metrics Error:', error.message);
    
    // Return structured fallback metrics
    const fallbackMetrics = generateFallbackMetrics(event.body ? JSON.parse(event.body).coinSymbol : 'UNKNOWN');

    return {
      statusCode: 200, // Return 200 so frontend gets fallback
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        success: false,
        metrics: fallbackMetrics,
        error: error.message,
        fallback: true,
        timestamp: new Date().toISOString()
      })
    };
  }
};

// Generate fallback metrics when API fails
function generateFallbackMetrics(coinSymbol) {
  return {
    tokenUnlockSchedule: { value: "N/A", unit: "percentage" },
    tvl: { value: "N/A", unit: "USD" },
    supplyDynamics: { type: "N/A", rate: "N/A" },
    activeAddresses: { value: "N/A", period: "daily" },
    transactionVolume: { count: "N/A", valueUSD: "N/A" },
    protocolRevenue: { value: "N/A", unit: "USD", period: "monthly" },
    fdv: { value: "N/A", unit: "USD" },
    users: { value: "N/A" },
    developmentActivity: { commits: "N/A", period: "30 days" },
    securityAudits: { count: "N/A" },
    onChainActivity: { trend: "N/A" },
    liquidity: { value: "N/A", unit: "USD" },
    tradingVolume: { value: "N/A", unit: "USD", period: "24h" },
    communitySize: { followers: "N/A" },
    partnerships: { count: "N/A" },
    ecosystemFlows: { value: "N/A", unit: "USD" },
    pfRatio: { value: "N/A" },
    mcapTvlRatio: { value: "N/A" }
  };
}